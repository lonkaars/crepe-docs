\documentclass{projdoc}
\input{meta.tex}

\title{Research document}

\begin{document}
\tablestables
\newpage

\section{Introduction}

\section{Game engine}

\subsection{Introduction}

To build a game engine, it must first be understood how it operates. The
functionalities it requires and how these functionalities work together must be
determined. In this section, the general functioning of a game engine and the
different parts required are described.

\subsection{Findings}

A game engine is not the game itself but a platform with which games are built. It
should provide the functionalities with which the game is constructed. The purpose of
a game engine is not to create data out of nothing. Instead, data is read, and the
correlating features and effects are generated. However, the engine is also used to
create these files, referred to as ``assets.'' The game engine must be able to accept
a certain format of these assets---whether levels, sprites, or textures---and convert
them into usable data.

\subsubsection{Layers}

A game engine is composed of multiple layers, each with its own functions. These
layers are divided into the following categories:\noparbreak
\begin{description}
	\item[Resource manager] Responsible for what happens when the engine is launched,
		including loading data formats.
	\item[Application] Manages the run loop, time, code execution, and events
		(e.g.~input events).
	\item[Window/\glspl{hid}] Handles input and events.
	\item[Renderer] Responsible for drawing the necessary objects on the screen,
		usually once per frame.
	\item[Debugging support] Provides testing for the engine, such as logging or
		performance profiling.
	\item[Scripting layer] Runs scripts, such as Lua or Python.
	\item[Memory systems] Handles and monitors memory usage.
	\item[\gls{ecs}] Provides a modular way to create game objects, add physics, and
		define how the engine interacts with objects.
	\item[Physics] Adds specific physics to objects.
	\item[Audio] Processes audio.
	\item[AI] Provides artificial inteligent behavior.
\end{description}

\subsubsection{ECS}

A game engine must have the ability to keep track and update several game objects. To
do this most game engines employ an \gls{ecs} model which uses modulair components to
give entities properties and features. The need for an entity component system arises
because multiple game objects are required to create a scene in a game. These game
objects exist within the scene and perform actions, such as a UI display for a score.
This game object does not need to be rendered; it could be a script running in the
background. It could also be a player sprite that is controlled. These entities need
to be aware of other entities, for example, during collisions. For this to function,
a scene is required to host all game objects. Within this scene, the game objects
must be stored efficiently, and entities must be provided with the required behavior,
such as audio, position, or physics. To create diverse entities with specific
functions: A scene can contain many different kinds of entities, each with different
properties and functions. But no matter how different each entity is, it remains an
entity. To assign properties and functions to entities, components are used. Entt is
an example of an \gls{ecs}.
% TODO: ref?entt

\subsection{Conclusion}

\section{Third-party Tools}

\subsection{Introduction}

Developing a game engine from scratch requires a significant amount of time, as many
different features are necessary. Fortunately, some of these features have already
been developed and can be reused in the form of frameworks and third-party
tools/libraries. The decision to use third-party libraries, and the selection of
which ones to use, directly influences the development process of the game engine. In
this section, several third-party frameworks and tools available for use are
described.

\subsection{Findings}

\subsubsection{Media Frameworks}

A game engine must have the ability to handle user input, render graphics, and
process audio. Several large frameworks are available that provide these features and
are already widely used by other game engines. The two most popular and
best-supported options are \gls{sdl2} and \gls{sfml}.

\paragraph{SDL2}

% TODO: ref?sdl2
According to its official website, \gls{sdl2} is \emph{``a cross-platform development
library designed to provide low-level access to audio, keyboard, mouse, joystick, and
graphics hardware via \gls{opengl} and \gls{d3d}. It is used by video playback
software, emulators, and popular games, including Valve's award-winning catalog and
many Humble Bundle games.''} \gls{sdl2} is written in the C programming language, and
therefore, structs and functions are used instead of objects and methods.

The advantages of \gls{sdl2} are:\noparbreak
\begin{itemize}
	\item Controller support is provided.
	\item 2D and 3D rendering are supported.
	\item Broad multiplatform support is offered, including older consoles such as the
		Wii.
	\item Low-level control is available.
	\item A large community ensures wide usage.
	\item Extended libraries can be used to add functionalities, such as SDL\_Mixer for
		sound.
\end{itemize}

The disadvantages of \gls{sdl2} are:\noparbreak
\begin{itemize}
	\item A limited built-in 2D renderer is provided.
	\item Extended libraries require setup.
\end{itemize}

\paragraph{SFML}

\gls{sfml} is a simple framework consisting of five modules: audio, graphics,
network, system, and window. This framework, written in C++, was designed to simplify
game development.

The advantages of \gls{sfml} are:
\begin{itemize}
	\item Object-oriented design is provided since it is written in C++.
	\item A built-in 2D renderer is available for ease of use.
	\item A built-in audio system is included.
	\item Cross-platform support is available for Linux, Windows, and macOS.
	\item Networking capabilities are provided for multiplayer or networked
		applications.
\end{itemize}

The disadvantages of \gls{sfml} are:
\begin{itemize}
	\item The 2D rendering engine may experience performance issues in large-scale
		games.
	\item The community is smaller compared to \gls{sdl2}.
	\item No native 3D support is provided.
	\item Not all image formats are supported.
\end{itemize}

\subsubsection{Audio}

for audio some options could be: FMOD, Wwise, or iirKlang

\subsection{Conclusion}

\section{Gameloop/resource manager}

\subsection{Introduction}

\subsection{Findings}

\subsection{Conclusion}

\section{Rendering}

\subsection{Introduction}

\subsection{Findings}

\subsection{Conclusion}

\section{Event manager}

\subsection{Introduction}

\subsection{Findings}

\subsection{Conclusion}

\section{Memory/debugging}

\subsection{Introduction}

\subsection{Findings}

\subsection{Conclusion}

\section{Physics/scripting}

%links
%ragdoll info: https://learn.unity.com/tutorial/creating-ragdolls-2019#649c42abedbc2a04c2145ce7
%softbody info: https://www.greenfoot.org/scenarios/29502
.
%2d box concepts: https://box2d.org/
%liquidfun (fork of box2d): https://google.github.io/liquidfun/
%Chipmunk2D: https://chipmunk-physics.net/
% particel systemhttps://learn.unity.com/tutorial/introduction-to-particle-systems#
%rigid body:https://docs.unity3d.com/ScriptReference/Rigidbody.html

\subsection{Introduction}
This part of the research explains physcis concepts and the use of physics in a game engine. Furthermore, it examines the ease of using a physics engine compared to implementing physics from scratch. Ultimately, a recommendation will be provided on whether using a physics engine is more feasible than a custom implementation.


\subsection{Physics concepts}


%Physics core concepts: https://bluebirdinternational.com/game-physics/#:~:text=Game%20physics%20is%20implemented%20using,solid%20and%20deformable%20objects%2C%20respectively

%ragdoll https://bluebirdinternational.com/ragdoll-physics/

\subsubsection{Kinematics}
Kinematics in game physics involves calculating the position, velocity, and acceleration of objects to simulate realistic motion. It affects everything from character movement to projectiles and vehicles. Collision detection is key, as it determines when objects collide and how they respond, including any damage or effects. Kinematics also helps create lifelike animations, like jumping or running, enhancing the game's realism and immersion.
\begin{itemize}
	\item mass
	\item speed
	\item direction
	\item collision detection
\end{itemize}


\subsubsection{Dynamics}
Dynamics simulate object interactions and forces, such as gravity and friction, to enhance realism. It includes rigid body, soft body, and fluid dynamics. For example, it affects car movements in racing games and projectiles in shooters. Balancing dynamics is crucial to maintain performance. Ragdoll physics, a related concept, models a character’s body as interconnected rigid bodies for realistic movement.
\begin{itemize}
	\item rigid body dynamics
	\item soft body dynamics
	\item fluid dynamics
	\item ragdoll physics
\end{itemize}


\subsubsection{Collision}
Collision detection is the process of determining when two or more objects in the game world come into contact with each other. There are several techniques used for collision detection.
\begin{itemize}
	\item bounding boxes
	\item bounding spheres
	\item mesh-based collision
\end{itemize}
These techniques involve creating simple shapes around the objects and checking if they intersect with each other.

\subsubsection{Rigidbody}
Rigidbodys deels with the behavior of of non deformable solid objects. it has some physical properties.
\begin{itemize}
	\item mass
	\item velocity
	\item angular velocity
	\item orientation
\end{itemize}
To calculate all forces applied to the rigid body the most used algoritm is Newton-Euler equations. The alogritm is about mass an conservation of energy.

\subsubsection{Softbody}
Soft body dynamics simulates deformable objects like cloth, fluids, and flesh, adding complexity beyond rigid body dynamics. Key techniques include:
\begin{itemize}
	\item Finite Element Method: Divides the object into small elements that interact based on physical laws.
	\item Mass-Spring Systems: Uses masses and springs to model deformation and stretching.
\end{itemize}
These methods enhance game realism by creating lifelike clothing, natural water effects, and realistic collision deformations. However, they are resource intensive an require precise calculations to avoid unrealistic results.

\subsubsection{Particle Systems}
Particle systems simulate numerous small objects to create larger effects like dust, smoke, fire, or explosions. These effects can add an extra layer of realism to a game.

\subsubsection{Fluid Dynamics}
Fluid dynamics shows how fluids move and behave. In game physics, it simulates liquids like water or lava, adding complexity and realism to games with fluid interactions.

\subsubsection{Aerodynamics}
Aerodynamics shows the movement of air and its interaction with solid objects. In video games, it simulates how objects like airplanes or birds move through the air, adding a realistic touch to games involving flight or gliding.

\subsection{Implementation of Physics}

To know what the best Physics solution is for a project a list has been created with physics concepts.This list shows how much effort it is to implement a feature and if an engine has the feature available. For this list three physics engines have been found that can provide 2d physics.

\subsubsection{Physics comparison}

\begin{itemize}
    \item Rigid Body Dynamics
    \item Soft Body Dynamics
    \item Particle Systems
    \item Fluid Dynamics
    \item Collision Detection
    \item Aerodynamics
    \item Ragdoll Physics
    \item Constraints %box2d
    \item Joint Limits %box2d
    \item Joint Motors %box2d
    \item Joint Springs %box2d
    \item World Simulation %box2d
    \item Solver %box2d
\end{itemize}

\subsubsection{Physics Engines}

\paragraph{Box2D}
\begin{description}
	\item[Description:] One of the most popular and widely used open-source 2D physics engines, Box2D is known for its simplicity, robustness, and efficiency.
	\item[License:] MIT License
\end{description}

\paragraph{LiquidFun}
\begin{description}
	\item[Description:] A fork of Box2D, LiquidFun adds particle-based fluid simulation to Box2D's rigid body dynamics. It’s ideal for games that require both solid and fluid dynamics.
	\item[License:] Apache License 2.0
\end{description}

\paragraph{Chipmunk2D}
\begin{description}
	\item[Description:] A lightweight and fast 2D physics engine that emphasizes ease of use and flexibility. Chipmunk2D is designed to be simple enough to understand and integrate but powerful enough for complex simulations.
	\item[License:] MIT License
\end{description}



\subsection{Findings}

\subsection{Conclusion}

\section{Conclusion}

\section{Gameobjects/components}

\subsection{Introduction}

\subsection{Findings}

\subsection{Conclusion}

\section{Conclusion}

\end{document}
